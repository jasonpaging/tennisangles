<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tennis Angles Visualization</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div>
        <div class="options">
            <select id="scenarioSelector">
                <option value="Scenario0">Default Scenario</option>
                <option value="Scenario1">Alley Close to Net</option>
                <option value="Scenario2">Baseline and net player</option>
            </select>
            <label for="handednessToggle">Lefty</label>
            <input type="checkbox" id="handednessToggle">
        </div>
        <div class="court" id="court">
            <canvas id="courtCanvas"></canvas>
            <div class="service-boxes"></div>
            <div class="center-line"></div>
            <div class="doubles-alley"></div>
            <div id="tennisball"></div>
            <div class="net"></div>
            <div class="description">Passing Shot Shadow</div>       
        </div>
        <div id="hitter1"></div>
        <div id="returner1"></div>

    </div>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            const toggleSwitch = document.getElementById('handednessToggle');
            const court = document.getElementById('court');
            const net = document.querySelector('.net');
            const canvas = document.getElementById('courtCanvas');
            const ctx = canvas.getContext('2d');
            const tennisBall = document.getElementById('tennisball');
            const hitter1 = document.getElementById('hitter1');
            const returner1 = document.getElementById('returner1');
              
            //const canvasRect = canvas.getBoundingClientRect();

            function toXCanvas(i, courtRect){
                return (i- courtRect.left)/(courtRect.width /780);
            }

            function toYCanvas(i, courtRect){
                return (i- courtRect.top)/(courtRect.height/360);
            }

            function getCoordinates(obj, courtRect) {
                const rect = obj.getBoundingClientRect();
                return {
                    x: (rect.left - courtRect.left + (rect.width /2)),
                    y: (rect.top - courtRect.top + (rect.height /3))
                };
            }

            function getCoordinatesWithHandedness(coords,player="hitter",side="right", hitterHandedAdjustment=0) {
                playerAdj = 1;
                sideAdj = -1
                if (player==="hitter"){
                    playerAdj = -1;
                    }
                if (side==="left"){
                        sideAdj = 1;
                    }                    
                coords.y = coords.y + (hitterHandedAdjustment *.7 * playerAdj * sideAdj)
                return coords;
            }

            function getDistanceBetweenPoints(x1, y1, x2, y2) { 
                const deltaX = x2 - x1; 
                const deltaY = y2 - y1; 
                return Math.sqrt(deltaX * deltaX + deltaY * deltaY); 
            }

            function rotatePoint(cx, cy, angle, x, y) {
                const radians = angle * (Math.PI / 180);
                const cos = Math.cos(radians);
                const sin = Math.sin(radians);
                const nx = (cos * (x - cx)) + (sin * (y - cy)) + cx;
                const ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
                return { x: nx, y: ny };
            }

            function getRotatedBoundingBox(x, y, width, height, angle) {
                const cx = x + width / 2;
                const cy = y + height / 2;

                const corners = [
                    rotatePoint(cx, cy, angle, x, y),
                    rotatePoint(cx, cy, angle, x + width, y),
                    rotatePoint(cx, cy, angle, x, y + height),
                    rotatePoint(cx, cy, angle, x + width, y + height)
                ];

                const minX = Math.min(...corners.map(p => p.x));
                const minY = Math.min(...corners.map(p => p.y));
                const maxX = Math.max(...corners.map(p => p.x));
                const maxY = Math.max(...corners.map(p => p.y));

                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY,
                    midTop: { x: (corners[0].x + corners[1].x) / 2, y: (corners[0].y + corners[1].y) / 2 },
                    midBottom: { x: (corners[2].x + corners[3].x) / 2, y: (corners[2].y + corners[3].y) / 2 },
                };
            }

            function getLinesIntersectionPoint(x1, y1, x2, y2, x3, y3, x4, y4) {
                const slopeA = (y2 - y1) / (x2 - x1);
                const interceptA = y1 - slopeA * x1;
                const slopeB = (y4 - y3) / (x4 - x3);

                const interceptB = y3 - slopeB * x3;
                const x = (interceptB - interceptA) / (slopeA - slopeB);
                const y = slopeA * x + interceptA;
                return { x: x, y: y };
            }


            function drawPolygon(points, fillColor) {
                ctx.beginPath();
                ctx.lineWidth = 0;
                ctx.moveTo(points[0].x, points[0].y); // Move to the first point
                
                // Loop through the rest of the points
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }

                ctx.closePath(); // Close the path
                ctx.fillStyle = fillColor; // Set the fill color
                ctx.fill(); // Fill the polygon
            }

            function getPointFromAngle(x1, y1, angle, length) {
                // Convert the angle to radians
                const angleRad = angle * (Math.PI / 180);
                
                // Calculate the end point using trigonometry
                const x2 = x1 + length * Math.cos(angleRad);
                const y2 = y1 + length * Math.sin(angleRad);
                return { x: x2, y: y2 };

            }

            function drawLineOfSight() {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
                const courtRect = court.getBoundingClientRect();
                const targetBaselineTop = { x: courtRect.right, y: courtRect.top };
                const targetBaselineBottom = { x: courtRect.right + 1, y: courtRect.top + courtRect.height };     

                const returnerRect = returner1.getBoundingClientRect();    
                const returnerCoords = getCoordinates(returner1, courtRect);

                const hitterRect = hitter1.getBoundingClientRect();
                const hitterHandedAdjustment = hitterRect.height /2;
                const hitterHandedness = toggleSwitch.checked ? 'left' : 'right';
                const hitterCenter = getCoordinates(hitter1, courtRect);

                tennisBall.style.left = `${hitterRect.left - courtRect.left + (hitterRect.width * 1)}px`;
                if (hitterHandedness == 'right') {
                    tennisBall.style.top = `${hitterRect.bottom - (hitterRect.height * .2) - courtRect.top}px`;
                    hitter1Scale = 1;
                    hitter1Deg = 0;
                } else {
                    tennisBall.style.top = `${hitterRect.top + (hitterRect.height * .1) - courtRect.top}px`;
                    hitter1Scale = -1;
                    hitter1Deg = 180;
                }
                const hitterCoords = getCoordinates(tennisBall, courtRect);

                // Calculate the angle between hitter and returner 
                const facingAngle = Math.atan2(returnerCoords.y - hitterCenter.y, returnerCoords.x - hitterCenter.x) * 180 / Math.PI; 
                // Calculate rotation to the returner 
                const returnerRectRotated = getRotatedBoundingBox(returnerRect.left - courtRect.left, returnerRect.top - courtRect.top, returnerRect.width, returnerRect.height, -1* facingAngle);
                const returnerBlockingCoords = {topx: returnerRectRotated.midTop.x, topy: returnerRectRotated.midTop.y, botx: returnerRectRotated.midBottom.x, boty: returnerRectRotated.midBottom.y};

                // Move sprites
                returner1.style.transform = `rotate(${facingAngle}deg)`;
                hitter1.style.transform = `scaleX(${hitter1Scale}) rotate(${hitter1Deg}deg)`;

                const playerDistance = getDistanceBetweenPoints(hitterCoords.x, hitterCoords.y, returnerCoords.x, returnerCoords.y);

                points = []
                // Lines from the tennisball to the returner (light gray lines)
                ctx.beginPath();
                ctx.moveTo(hitterCoords.x, hitterCoords.y);
                ctx.lineTo(returnerBlockingCoords.topx, returnerBlockingCoords.topy);
                points.push({x: returnerBlockingCoords.topx, y: returnerBlockingCoords.topy});
                intersectionPoint = getLinesIntersectionPoint(hitterCoords.x, hitterCoords.y, returnerBlockingCoords.topx, returnerBlockingCoords.topy, targetBaselineTop.x,targetBaselineTop.y,targetBaselineBottom.x,targetBaselineBottom.y);
                points.push({x: intersectionPoint.x, y: intersectionPoint.y});
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(hitterCoords.x, hitterCoords.y);
                ctx.lineTo(returnerBlockingCoords.botx, returnerBlockingCoords.boty);
                intersectionPoint = getLinesIntersectionPoint(hitterCoords.x, hitterCoords.y, returnerBlockingCoords.botx, returnerBlockingCoords.boty, targetBaselineTop.x,targetBaselineTop.y,targetBaselineBottom.x,targetBaselineBottom.y);
                points.push({x: intersectionPoint.x, y: intersectionPoint.y});
                points.push({x: returnerBlockingCoords.botx, y: returnerBlockingCoords.boty});
                // complete polygon points
                points.push({x: returnerBlockingCoords.topx, y: returnerBlockingCoords.topy});
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 1;
                ctx.stroke();

                // polygon that extends the lines from the tennis ball behind the returner and shades the area dark gray
                drawPolygon(points, 'rgba(0, 0, 0, 0.2)');
                points = []

                // Line from top of returner to baseline with angle increased based on distance to hitter
                ctx.beginPath();
                ctx.moveTo(returnerBlockingCoords.topx, returnerBlockingCoords.topy);
                points.push({x: returnerBlockingCoords.topx, y: returnerBlockingCoords.topy});
                // calculate an extension on both sides of the returner that they can reach/strafe to
                strafeCoords = getPointFromAngle(returnerBlockingCoords.topx, returnerBlockingCoords.topy, facingAngle - 85, playerDistance/5);
                ctx.lineTo(strafeCoords.x, strafeCoords.y);
                points.push({x: strafeCoords.x, y: strafeCoords.y});
                intersectionPoint = getLinesIntersectionPoint(hitterCoords.x, hitterCoords.y, strafeCoords.x, strafeCoords.y, targetBaselineTop.x,targetBaselineTop.y,targetBaselineBottom.x,targetBaselineBottom.y);
                ctx.lineTo(intersectionPoint.x, intersectionPoint.y);
                points.push({x: intersectionPoint.x, y: intersectionPoint.y});
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(returnerBlockingCoords.botx, returnerBlockingCoords.boty);
                strafeCoords = getPointFromAngle(returnerBlockingCoords.botx, returnerBlockingCoords.boty, facingAngle + 85, playerDistance/5);
                ctx.lineTo(strafeCoords.x, strafeCoords.y);
                intersectionPoint = getLinesIntersectionPoint(hitterCoords.x, hitterCoords.y, strafeCoords.x, strafeCoords.y, targetBaselineTop.x,targetBaselineTop.y,targetBaselineBottom.x,targetBaselineBottom.y);
                ctx.lineTo(intersectionPoint.x, intersectionPoint.y);
                points.push({x: intersectionPoint.x, y: intersectionPoint.y});
                points.push({x: strafeCoords.x, y: strafeCoords.y});
                points.push({x: returnerBlockingCoords.botx, y: returnerBlockingCoords.boty});
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                points.push({x: returnerBlockingCoords.topx, y: returnerBlockingCoords.topy});
                drawPolygon(points, 'rgba(0, 0, 0, 0.4)');
            }
            
            function handlePlayerSelection(event) { 
                const scenario = event.target.value; 
                switch (scenario) { 
                    case 'Scenario0': 
                        hitter1.style.left = 'calc(80vw *(100/780))';
                        hitter1.style.top = 'calc(80vw *(165/780))'; 
                        returner1.style.left = 'calc(80vw *(600/780))'; 
                        returner1.style.top = 'calc(80vw *(160/780))';
                        toggleSwitch.checked = false;
                        break; 
                    case 'Scenario1': 
                        hitter1.style.left = 'calc(80vw *(370/780))'; 
                        hitter1.style.top = 'calc(80vw *(12/780))'; 
                        returner1.style.left = 'calc(80vw *(525/780))'; 
                        returner1.style.top = 'calc(80vw *(100/780))'; 
                        toggleSwitch.checked = true;
                        break; 
                    case 'Scenario2': 
                        hitter1.style.left = 'calc(80vw *(60/780))'; 
                        hitter1.style.top = 'calc(80vw *(275/780))'; 
                        returner1.style.left = 'calc(80vw *(525/780))'; 
                        returner1.style.top = 'calc(80vw *(250/780))'; 
                        toggleSwitch.checked = false;
                        break; 
                }
                drawLineOfSight();
            }

            function resizeCanvas() { 
                canvas.width = court.clientWidth; 
                canvas.height = court.clientHeight; 
                drawLineOfSight(); // Redraw on resize 
            }
            
            [hitter1, returner1].forEach(player => {
                let offsetX, offsetY;
                // Touch events
                player.addEventListener('touchstart', function(e) {
                    const touch = e.touches[0];
                    offsetX = touch.clientX - player.getBoundingClientRect().left;
                    offsetY = touch.clientY - player.getBoundingClientRect().top;
                }, { passive: false });
                player.addEventListener('touchmove', function(e) {
                    const touch = e.touches[0];
                    const newX = touch.clientX - offsetX;
                    const newY = touch.clientY - offsetY;
                    player.style.left = `${newX}px`;
                    player.style.top = `${newY}px`;
                    e.preventDefault(); // Prevent scrolling during touchmove
                    drawLineOfSight();
                }, { passive: false });
                player.addEventListener('touchend', function(e) {
                    // You can handle touchend event here if needed
                    console.log(`player position: ${player.style.left}, ${player.style.top}`);
                }, { passive: false });

                // Mouse events
                player.addEventListener('mousedown', function(e) {
                    offsetX = e.clientX - player.getBoundingClientRect().left;
                    offsetY = e.clientY - player.getBoundingClientRect().top;
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });

                function onMouseMove(e) {
                    const newX = e.clientX - offsetX;
                    const newY = e.clientY - offsetY;
                    player.style.left = `${newX}px`;
                    player.style.top = `${newY}px`;
                    drawLineOfSight();
                }

                function onMouseUp(e) {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }
                
            });

            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('orientationchange', resizeCanvas);                       
            toggleSwitch.addEventListener('change', drawLineOfSight);
            scenarioSelector.addEventListener('change', handlePlayerSelection);

            resizeCanvas(); // Initial call to set canvas size, draw elements
        });
    </script>
</body>
</html>
